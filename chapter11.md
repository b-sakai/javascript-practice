# 第１１章　メタプログラミング

標準的ではない振る舞いを持つオブジェクトの作成や、ジェネリックオブジェクトを使うコードを書くために使える高度なAPIをこの章で深く探求しよう


## 11.1 シンボル
文字列以外でオブジェクトのプロパティ名に使える唯一の型である
「周知の」シンボルでプロパティを定義することいよって、ある種のAPIメソッドの振る舞いをカスタマイズすることができる

本書を通じてみてきたように、JavaScriptオブジェクトはString型のキーを持つ
けれども、キーに文字列を使うにはいくつかの制限がある
モダンJavaScriptには、オブジェクトのキーとして使える第２の型がある -> Symbol型!

シンボルは文字列の「ラベル」を持つだけで、文字列ではない
シンボルはユニークだ！
　これが、シンボルの主な利点！
　必ずユニークになる文字列キーを作りたいとき、たとえば文字列にカウンタやタイムスタンプや乱数の
　値を加えても、それで十分とは断言できないだろう

シンボルを作るのにnewは使えない（例外が送出される）


## 11.2 シンボルプロパティによるカスタマイズ
## 11.3 プロパティの属性
## 11.4 プロパティの列挙
## 11.5 プロパティの存在をチェックする
## 11.6 オブジェクトの保護
## 11.7 オブジェクトを作成または更新する
## 11.8 プロトタイプのアクセスと更新
## 11.9 オブジェクトのクローンを作る

「深いコピー」、「クローン」を作成できる関数

展開演算子 -> コピーされるのは列挙可能なプロパティだけ、プロトタイプについては何もしない

const cloned = Object.create(Object.getPrototypeOf(original))
const cloned = Object.create(Object.getOwnPropertyDescriptors(original))
これでプロトタイプとすべてのプロパティをコピーすることができるが、可変なプロパティ値が複製されない
オリジナルを変更すると、クローンも変更されてしまう

コレを解決するには全ての値を再帰的にクローニングするしかない
しかし、このバージョンも循環参照があると失敗する

まだ複製されていないオブジェクトに遭遇したら、オリジナルの参照と複製の参照をマップに追加する


## 11.10 関数のプロパティ

Objectクラスのメソッドを論じたところで、次は関数オブジェクトに進もう
Functionキーワードを使って定義された関数には、どれも次の３つの列挙可能ではないプロパティがある

・name: この関数を定義した名前、ただし匿名関数の場合は、この関数を割り当てる変数の名前
・length: 引数の数（restパラメータは数えない）
・prototype: プロトタイププロパティを記入するためのオブジェクト

古典的なJavaScriptでは、関数とコンストラクタの間に違いがないことを思い出そう
たとえstricgtモードでもnewを付けてあらゆる関数を呼びだせるのだ
だから、どの関数もprototypeオブジェクトを持っている

関数のprototypeオブジェクトを詳しく見ていこう
列挙可能なプロパティがなく、元のコンストラクタ関数を参照する列挙不可能なconstructorプロパティを
1個持つ

## 11.11 引数の束縛とメソッドの呼び出し

関数のbindメソッドは、元の関数の引数群の一部を固定した、もう一つの関数を返す
callメソッドもbindに似ている、ただし、すべての引数が提供されて、その関数またはメソッドが呼び出される
applyもcallに似ているが、this以外の引数が配列に（あるいは配列のようなオブジェクトに）入っている

メモ
JavaScriptにsuperキーワードが導入される以前は、スーパークラスのコンストラクタを呼び出すために、
bindかcallかapplyを使う必要が合った


## 11.12 プロキシ

「プロキシ」（proxy）は、ユーザーには操作対象のオブジェクトに見えるが、実はその操作（プロパティの
アクセス、プロトタイプのアクセス、メソッドの呼び出し）を横取り(intercept)しているものだ。
これらのアクションを横取りすることによって、プロキシは任意の仕事を行うことができる
ORM（Object-Relational Mapper）

先に具体例がほしいのだけど。。


・プロパティのアクセスや書き換えを自動的にロギング
　プロキシを介してアクセスすることで本来のオブジェクトにはない機能をトラップ関数を通じて呼び出せる
・プロパティのアクセスを制御（たとえば認証や、機密データの保護）
　アクセスを制御したプロキシを用いて直接オブジェクトをいじらない
・動的プロパティ（たとえばDOM要素やデータベースのカラム）
・リモートコールをローカルであるかのように行う

プロキシを構築するには、２つのオブジェクトを提供する

・target：操作を制御したい対象のオブジェクト
・handler：プロキシが操作されるとき呼び出される「トラップ関数」（trap function）を持つオブジェクト

例：
const obj = { name: 'Harry Smith', salary: 100000 }
const logHandler = {
    get(target, key, receiver) { // トラップ関数
        cosnt result = target[key]
        console.log(`get ${key.toString()} as ${result}`)
        return result
    },
    set(target, key, value, receiver) {
        console.log(`set ${key.toString()} as ${value}`)
        target[key] = value
        return true
    }
}
const proxy = new Proxy(obj, logHandler) // ここではget, setのtarget引数はobjになる
// receiverは実際にプロパティがアクセスされるオブジェクトでそれがproxyオブジェクトになる
（他のオブジェクトのプロトタイプチェインに入っているのでなければ）
// オリジナルのオブジェクトではなくプロキシを監視したコードに与える必要がある
proxy.salary = 20000 // set salary to 20000
delete proxy.salary // トラップしない操作はターゲットに渡されるので、ターゲットからsalaryフィールドを削除する


## 11.13 Reflectクラス

13種類のトラップ演算はReflectクラスで実装されている
トラップのアクションを手作業で実装する代わりに対応するReflect関数を呼び出すことができる
なかなかややこしいですねー

Refelectクラスはプロキシで使うために設計されたものだが、そのうち３つのメソッドはそれ自身に
利用価値がある　というのは、古典的な同等の手段より少し便利に使えるからだ

１、Reflect.deletePropertyは削除が成功したかどうかを真偽値で返してくれる
　　delete演算子はそうしてくれない
２，Reflect.definePropertyは定義に成功したかどうかを真偽値で返してくれる
　　Object.definePropertyは失敗すると例外を送出する
３，Reflect.apply(f, thisArg, args)には必ずFunction.prototype.applyを呼び出すという保証がある
　　けれども、f.apply(thisArg, args)はそうしないかもしれない

## 11.14 プロキシの不変条件

プロキシ演算を実装するときは、無意味な値を出していないか、仮想マシンにチェックされる

・constructはオブジェクトを返さなければならない
・getOwnPropertyDescriptorはディスクリプタオブジェクトまたはundefinedｗ返さなければならない
・getPrototypeOfはオブジェクトまたはnullを返さなければならない

さらに仮想マシンは、プロキシ演算の一貫性もチェックする
プロキシはターゲットのいつかの側面を尊重しなければならない

・ターゲットの「書き込み不可」(nonwritable)プロパティ
・ターゲットの「設定不可」(nonconfigurable)プロパティ
・「拡張不可」(nonextensible)なターゲット

ECMAScriptの仕様に、プロキシが満たさなければならない「不変条件」(invariants)が記述されている
たとえばプロキシにおけるget演算の記述には、次の条件が含まれている
「プロパティについて（getによって）報告される値は対応するターゲットオブジェクトのプロパティが「書き込み不可」で「設定不可」な独自データプロパティであれば、そのターゲットオブジェクトのプロパティ値と同じでなければならない」
同様に、もしターゲットプロパティが設定可能でなければ、hasはそれを隠すことができない
もしターゲットが拡張可能でなければ、getPrototypeOf演算は本物のプロトタイプを返さなければならない
hasとgetOwnPropetyDescriptorは本物のプロパティについて報告しなければならない

これらの「不変条件」が有効なのは、プロキシが自分のプロパティを追加することなく、既存のオブジェクトを強化するときである
遺憾ながら、プロキシが追加するプロパティについては嘘をつくことになる


おわかりのように、プロキシで動的なプロパティを実装するのは、まったく容易なことではない
プロパティはできるだけプロキシのターゲットに置くのが良い
たとえば領域（range）プロキシには、lengthプロパティとtoStringメソッドが必要だろう
それらはターゲットオブジェクトに追加すべきだ。トラップ中で処理スべきではない

演習問題多すぎわろた
こんなんやる気出るわけ無いやろ。。誰がやんねん。。。
JavaScript本業の人でも面倒なのでは？？

